### RC4

### Key-scheduling algorithm (KSA) 

**The [key-scheduling](https://en.wikipedia.org/wiki/Key_schedule) algorithm
is used to initialize the permutation in the array \"S\". \"keylength\"
is defined as the number of bytes in the key and can be in the range 1 ≤
keylength ≤ 256, typically between 5 and 16, corresponding to a [key
length](https://en.wikipedia.org/wiki/Key_length) of 40 -- 128 bits.
First, the array \"S\" is initialized to the [identity
permutation](https://en.wikipedia.org/wiki/Identity_permutation). S is
then processed for 256 iterations in a similar way to the main PRGA, but
also mixes in bytes of the key at the same time**

**for i from 0 to 255**

**S\[i\] := i**

**endfor**

**j := 0**

**for i from 0 to 255**

**j := (j + S\[i\] + key\[i
[mod](https://en.wikipedia.org/wiki/Modulo_operation) keylength\]) mod
256**

**swap values of S\[i\] and S\[j\]**

**endfor**

### Pseudo-random generation algorithm (PRGA)

**For as many iterations as are needed, the PRGA modifies the state and
outputs a byte of the keystream. In each iteration, the PRGA:**

-   **increments *i***

-   **looks up the *i*th element of S, S\[*i*\], and adds that to *j***

-   **exchanges the values of S\[*i*\] and S\[*j*\] then uses the
    > sum S\[*i*\] + S\[*j*\] (modulo 256) as an index to fetch a third
    > element of S (the keystream value K below)**

-   **then bitwise exclusive ORed (XORed) with the next byte of the
    > message to produce the next byte of either ciphertext or
    > plaintext.**

**Each element of S is swapped with another element at least once every
256 iterations.**

**i := 0**

**j := 0**

**while GeneratingOutput:**

**i := (i + 1) mod 256**

**j := (j + S\[i\]) mod 256**

**[swap values](https://en.wikipedia.org/wiki/Swap_(computer_science))
of S\[i\] and S\[j\]**

**K := S\[(S\[i\] + S\[j\]) mod 256\]**

**output K**

**endwhile**

**A Statistical Test Suite for Random and Pseudorandom Number Generators
for Cryptographic Applications**

**The need for random and pseudorandom numbers arises in many
cryptographic applications. For example, common cryptosystems employ
keys that must be generated in a random fashion. Many cryptographic
protocols also require random or pseudorandom inputs at various points,
e.g., for auxiliary quantities used in generating digital signatures, or
for generating challenges in authentication protocols.**

1.  **Frequency (Monobit) Test**

-   **Test Purpose**

> **The focus of the test is the proportion of zeroes and ones for the
> entire sequence. The purpose of this test is to determine whether the
> number of ones and zeros in a sequence are approximately the same as
> would be expected for a truly random sequence. The test assesses the
> closeness of the fraction of ones to ½, that is, the number of ones
> and zeroes in a sequence should be about the same. All subsequent
> tests depend on the passing of this test**

-   **Function Call**

> **Frequency(n), where: n The length of the bit string. Additional
> input used by the function, but supplied by the testing code: ε The
> sequence of bits as generated by the RNG or PRNG being tested; this
> exists as a global structure at the time of the function call; ε = ε1,
> ε2, ... , εn.**

-   **Test Statistic and Reference Distribution sobs**

> **The absolute value of the sum of the Xi (where, Xi = 2ε - 1 = ±1) in
> the sequence divided by the square root of the length of the sequence.
> The reference distribution for the test statistic is half normal (for
> large n). (Note: If z (where 2 obs z = s ; see Section 3.1) is
> distributed as normal, then \|z\| is distributed as half normal.) If
> the sequence is random, then the plus and minus ones will tend to
> cancel one another out so that the test statistic will be about 0. If
> there are too many ones or too many zeroes, then the test statistic
> will tend to be larger than zero.**

-   **Test Description**

(1) **Conversion to ±1: The zeros and ones of the input sequence (ε) are
    converted to values of --1 and +1 and are added together to produce
    Sn = X1 + X2+Λ+Xn , where Xi = 2εi -- 1.**

(2) **2-3 For example, if ε = 1011010101, then n=10 and Sn = 1 + (-1) +
    1 + 1 + (-1) + 1 + (-1) + 1 + (-1) + 1 = 2.**

(3) **(2) Compute the test statistic sobs =**
    $\frac{\left| \mathbf{Sn} \right|}{\sqrt{\mathbf{n}}}$

(4) **For the example in this section, sobs =**
    $\frac{\left| \mathbf{2} \right|}{\sqrt{\mathbf{10}}}$
    **=.632455532.**

(5) **Compute P-value =
    erfc**$\frac{\left( \mathbf{Sobs} \right)}{\mathbf{\sqrt{}n}}$**,
    where erfc is the complementary error function as defined**

-   **Decision Rule (at the 1% Level)**

If **the computed P-value is \< 0.01, then conclude that the sequence is
non-random. Otherwise, conclude that the sequence is random.**

-   **Conclusion and Interpretation of Results**

**Since the P-value obtained in step 3 of Section 2.1.4 is ≥ 0.01 (i.e.,
P-value = 0.527089), the conclusion is that the sequence is random. Note
that if the P-value were small (\< 0.01), then this would be caused by
Sn or obs s being large. Large positive values of Sn are indicative of
too many ones, and large negative values of Sn are indicative of too
many zeros.**

2.  **(0-1) Test**

**The purpose is to check the randomize []{dir="rtl"}** []{dir="rtl"}By
counting the number of zeros []{dir="rtl"}and ones and checking this :

If the difference between the number of once and zeros []{dir="rtl"}is
less than or equal result of multiply of(10 \* squre root of number of
element I want to check)

Then this test is success

Otherwise it will fail

**If :**

\|# of 0s in (x) - \# of 1s\| \<=10\*squrt(n)

**Then this test success**

3.  **(00) test**

> **This test check the randomize by counting how much numbers of (00)
> countinuously in the generating key**
>
> **If this number -- (number of element in class/4) is less than result
> of multiply of (10\*squre root of number of element )**
>
> **Then this test success**
>
> **Otherwice the test fail**

**If :**

\|# of 00 in (x) -- n/4\| \<= 10\*squrt(n)

**Then this test success**

4.  **Large number of consecutive of 0s test**

> **This test check the randomize by counting how large number of
> consecutive of 0s in the generating key**
>
> **If this is less than or equle the result of log2(numbers of
> elemens)**
>
> **Then this test success**
>
> **Otherwice the test fail**
>
> **If :**
>
> **Max_num.\_of\_ consecutive_0(x) \<=10\*log2(n)**

**Then this test success**

**5.Runs Test**

-   **Test Purpose**

**The focus of this test is the total number of runs in the sequence,
where a run is an uninterrupted sequence of identical bits. A run of
length k consists of exactly k identical bits and is bounded before and
after with a bit of the opposite value. The purpose of the runs test is
to determine whether the number of runs of ones and zeros of various
lengths is as expected for a random sequence. In particular, this test
determines whether the oscillation between such zeros and ones is too
fast or too slow.**

-   **Function Call**

**Runs(n), where: n The length of the bit string. Additional inputs for
the function, but supplied by the testing code: ε The sequence of bits
as generated by the RNG or PRNG being tested; this exists as a global
structure at the time of the function call; ε = ε1, ε2, ... , εn.**

-   **Test Statistic and Reference Distribution**

**Vn(obs): The total number of runs (i.e., the total number of zero
runs + the total number of one-runs) across all n bits. The reference
distribution for the test statistic is a χ2 distribution.**

-   **Test Description**

**Note: The Runs test carries out a Frequency test as a prerequisite.**

(1) **Compute the pre-test proportion π of ones in the input sequence: π
    =**
    $\frac{\sum_{}^{}\mathbf{j}^{\mathbf{\varepsilon}}\mathbf{j}}{\mathbf{n}}$

(2) ![](vertopal_4a37c92116e34a7a94b262d380542a60/media/image1.PNG){width="6.165277777777778in"
    height="4.072916666666667in"}**Determine if the prerequisite
    Frequency test is passed: If it can be shown that π ≥ τ 2 1- , then
    the Runs test need not be performed (i.e., the test should not have
    been run because of a failure to pass test 1, the Frequency
    (Monobit) test). If the test is not applicable, then the P-value is
    set to 0.0000. Note that for this test, τ
    =**$\frac{\mathbf{2}}{\mathbf{\sqrt{}n}}$ **has been pre-defined in
    the test code**

-   **Decision Rule (at the 1% Level)**

> **If the computed P-value is \< 0.01, then conclude that the sequence
> is non-random. Otherwise, conclude that the sequence is random**

-   **Conclusion and Interpretation of Results**

> **Since the P-value obtained in step 4 of Section 2.3.4 is ≥ 0.01
> (i.e., P-value = 0.147232), the conclusion is that the sequence is
> random. Note that a large value for Vn(obs) would have indicated an
> oscillation in the string which is too fast; a small value would have
> indicated that the oscillation is too slow. (An oscillation is
> considered to be a change from a one to a zero or vice versa.) A fast
> oscillation occurs when there are a lot of changes, e.g., 010101010
> oscillates with every bit. A stream with a slow oscillation has fewer
> runs than would be expected in a random sequence, e.g., a sequence
> containing 100 ones, followed by 73 zeroes, followed by 127 ones (a
> total of 300 bits) would have only three runs, whereas 150 runs would
> be expected**
>
> **\>\>The result 1 by c++ code:**
>
> **The result of input the 3 key numbers(5 , 9 , 4) as a key to
> generate 1000000 bits random generated key**
>
> **Frequency (Monobit) Test**
>
> **-success**
>
> **(0-1) Test**
>
> **-sucess**
>
> **(00) Test**
>
> **-success**
>
> **Large number of consecutive of 0 test**
>
> **-success**

**Runs Test**

**-sucess**

> **\>\>The result 2 by c++ code:**
>
> **The result of input the 4 key numbers(44 , 35 , 71 , 18) as a key to
> generate 1000000 bits random generated key**
>
> **Frequency (Monobit) Test**
>
> **-success**
>
> **(0-1) Test**
>
> **-sucess**
>
> **(00) Test**
>
> **-success**
>
> **Large number of consecutive of 0 test**
>
> **-success**

**Runs Test**

**-sucess**
